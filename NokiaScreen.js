// Based On: https://github.com/tmfksoft/nokia-screen
/*
LCDWIDTH = 84
LCDHEIGHT = 48
ROWPIXELS = LCDHEIGHT//6
PCD8544_POWERDOWN = 0x04
PCD8544_ENTRYMODE = 0x02
PCD8544_EXTENDEDINSTRUCTION = 0x01
PCD8544_DISPLAYBLANK = 0x0
PCD8544_DISPLAYNORMAL = 0x4
PCD8544_DISPLAYALLON = 0x1
PCD8544_DISPLAYINVERTED = 0x5
PCD8544_FUNCTIONSET = 0x20
PCD8544_DISPLAYCONTROL = 0x08
PCD8544_SETYADDR = 0x40
PCD8544_SETXADDR = 0x80
PCD8544_SETTEMP = 0x04
PCD8544_SETBIAS = 0x10
PCD8544_SETVOP = 0x80
*/

const lcdChars = require('./lcd-chars.js');
const SPI = require('pi-spi');
const PImage = require('pureimage');
const Jimp = require('jimp');
const gpio = require('rpi-gpio');
const debug = require('debug')('nokia-screen');

const LCDWIDTH = 84;
const LCDHEIGHT = 48;
class NokiaScreen {
	constructor(dc, rst, spi) {
		this.spi = spi;
		this.dc = dc;
		this.rst = rst;
		this.logo = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xFC, 0xFE, 0xFF, 0xFC, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF0, 0xF0, 0xE0, 0xE0, 0xC0, 0x80, 0xC0, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x1F, 0x3F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0xC7, 0xC7, 0x87, 0x8F, 0x9F, 0x9F, 0xFF, 0xFF, 0xFF, 0xC1, 0xC0, 0xE0, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0xFC, 0xFC, 0xFC, 0xFE, 0xFE, 0xFE, 0xFC, 0xFC, 0xF8, 0xF8, 0xF0, 0xE0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0xF1, 0xFB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x1F, 0x0F, 0x0F, 0x87, 0xE7, 0xFF, 0xFF, 0xFF, 0x1F, 0x1F, 0x3F, 0xF9, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x0F, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x7E, 0x3F, 0x3F, 0x0F, 0x1F, 0xFF, 0xFF, 0xFF, 0xFC, 0xF0, 0xE0, 0xF1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0xF0, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x0F, 0x1F, 0x3F, 0x7F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x7F, 0x1F, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 ];
		this.buffer = Buffer.from(this.logo);
		this.font = null;
		this.image = null; //PImage.make(LCDWIDTH,LCDHEIGHT);
		// this.ctx = this.image.getContext('2d');
		// this.ctx.imageSmoothingEnabled = false;

		// this.ctx.fillStyle = 'rgba(255, 255, 255, 1)';
		// this.ctx.fillRect(0,0,LCDWIDTH,LCDHEIGHT);
		
		debug("Class constructed");
	}
	command(c) {
		debug(`Executing command ${c}`);
		return new Promise( ( resolve, reject ) => {
			gpio.write(this.dc, false, err => {
				if (err) return reject(err);

				this.spi.transfer(Buffer.from([ c ]),function(err, buf) {
					var s = "";
					for (var i=0; i < buf.length; i++) {
						s = s + buf[i] + " ";
						//console.log(s);
					}
					resolve(buf);
				});
			});
		});
	}
	extended_command(c) {
		debug(`Executing extended command ${c}`);
		return this.command( 0x20 | 0x01 )
		.then( ()=> this.command(c) )
		.then( ()=> this.command(0x20) )
		.then( ()=> this.command(0x08 | 0x4) )
	}
	data(c) {
		debug("Writing data");
		return new Promise( ( resolve, reject ) => {
			gpio.write(this.dc, true, err => {
				return reject(err);
				this.spi.transfer(Buffer.from([ c ]),function(err, buf) {
					var s = "";
					for (var i=0; i < buf.length; i++) {
						s = s + buf[i] + " ";
						//console.log(s);
					}
					resolve(buf);
				});
			});
		});
	}
	begin(contrast = 55, bias = 4) {
		//gpio.setMode(gpio.MODE_BCM);
		debug("Starting class");
		return Promise.all([
			new Promise( (resolve, reject) => {
				debug(`D/C: Pin ${this.dc}`);
				gpio.setup(this.dc, gpio.DIR_OUT, err => {
					if (err) {
						debug(`D/C pin (${this.dc}) is not ready`);
						return reject(err);
					}
					debug(`D/C pin (${this.dc}) is ready`);
					resolve(this.dc);
				});
			}),
			new Promise( (resolve, reject) => {
				debug(`RESET Pin ${this.rst}`);
				gpio.setup(this.rst, gpio.DIR_OUT, err => {
					if (err) {
						debug(`Reset pin (${this.rst}) is not ready`);
						return reject(err);
					}
					debug(`Reset pin (${this.rst}) is ready`);
					resolve(this.rst);
				});
			}),
		])
		.then( pins => {
			debug(`Set pins ${pins}`);
		})
		.then( () => this.reset() )
		.then( () => this.set_bias(bias) )
		.then( () => this.set_contrast(contrast) )
		.then(new Promise((resolve, reject) => {
			new Jimp(LCDWIDTH, LCDWIDTH, '#FFFFFF', (err, image) => {
				if(err) reject(err);
				else{
					this.image = image;
					resolve();
				}
			});
		}))
		.then(Promise.all([
			new Promise((resolve, reject) => {
				var fontName = 'FONT_SANS_16_BLACK';
				console.log(Jimp[fontName]);
				Jimp.loadFont('./Leros.fon').then(font => {
					this.font = font;
					resolve();
				})
			})
		]))
	}
	reset() {
		// Resets the display
		debug("Resetting the display");
		return new Promise( (resolve, reject) => {
			debug(`Resetting display on pin ${this.rst}`);
			gpio.write(this.rst, false, err => {
				if (err) return reject(err);
				setTimeout( () => {
					gpio.write(this.rst, true, err => {
						if (err) return reject(err);
						resolve();
					});
				}, 100);
			});
		});
	}
	display() {
		debug("Pushing display buffer to display");
		return this.command(0x40)
		.then( () => this.command(0x80) )
		.then( () => {
			return new Promise( (resolve, reject) => {
				gpio.write(this.dc, true, err => {
					if (err) return reject(err);
					try {
						this.spi.transfer(this.buffer,function(err, buf) {
							var s = "";
							for (var i=0; i < buf.length; i++) {
								s = s + buf[i] + " ";
								//console.log(s);
							}
						});
					} catch (e) {
						reject(e);
					}
				});
			});
		});
	}
	draw(){
		// var data = [];
		// this.image.bitmap.data.forEach((el, i) => {
		// 	if(i%4 == 0){
		// 		data.push(el);
		// 	}
		// });

		// var index = 0;
		// const bits = 8;
		// const rows = LCDHEIGHT/bits;

		// for(var y=0; y<rows; y++ ){
		// 	for(var x=0; x<LCDWIDTH; x++){
		// 		var bin = [0,0,0,0,0,0,0,0];

		// 		for(var i=0; i<bits; i++){
		// 			var channelIndex = x+(y*LCDWIDTH*bits /* Start Position */)+(i*LCDWIDTH /* Offset Position */);
		// 			var value = data[channelIndex];
		// 			bin[i] = value < (255/2) ? 1 : 0; // 0 is White (off) 1 is Black(on)
		// 		}
				
		// 		this.buffer[index] = parseInt(bin.reverse().join(''), 2);
		// 		index++;
		// 	}
		// }
		

		this.display();
	}
	clear() {
		debug("Clearing display buffer");
		this.buffer = Buffer.from( new Array((LCDWIDTH * LCDHEIGHT / 8)).fill(0x00) );
	}
	set_contrast(contrast) {
		contrast = Math.max(0, Math.min(contrast, 127));
		debug(`Setting contrast to ${contrast} (Clamped 0-127)`);
		return this.extended_command( 0x80 | contrast );
	}
	set_bias(bias) {
		debug(`Setting bias to ${bias}`);
		return this.extended_command( 0x10 | bias );
	}
	text(x, y, text){

	}
}

const spi = SPI.initialize("/dev/spidev0.0");
let screen = new NokiaScreen(16, 18, spi);


screen.begin(55, 4).then( () => {
	console.log("Screen is ready");
	screen.image.print(screen.font, 0, 0, 'Hello world!');
	screen.draw();
})
.catch( err => {
	console.log(`Error on begin: `, err);
});


module.exports = NokiaScreen;