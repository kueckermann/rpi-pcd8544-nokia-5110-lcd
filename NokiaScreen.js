// Based On: https://github.com/tmfksoft/nokia-screen
/*
LCDWIDTH = 84
LCDHEIGHT = 48
ROWPIXELS = LCDHEIGHT//6
PCD8544_POWERDOWN = 0x04
PCD8544_ENTRYMODE = 0x02
PCD8544_EXTENDEDINSTRUCTION = 0x01
PCD8544_DISPLAYBLANK = 0x0
PCD8544_DISPLAYNORMAL = 0x4
PCD8544_DISPLAYALLON = 0x1
PCD8544_DISPLAYINVERTED = 0x5
PCD8544_FUNCTIONSET = 0x20
PCD8544_DISPLAYCONTROL = 0x08
PCD8544_SETYADDR = 0x40
PCD8544_SETXADDR = 0x80
PCD8544_SETTEMP = 0x04
PCD8544_SETBIAS = 0x10
PCD8544_SETVOP = 0x80
*/

const { loadFont, fonts } = require('./font/font');
loadFont('./font/large', 'LARGE');
loadFont('./font/small', 'SMALL');

const SPI = require('pi-spi');
const gpio = require('rpi-gpio');
const debug = require('debug')('nokia-screen');

const LCDWIDTH = 84;
const LCDHEIGHT = 48;
class NokiaScreen {
	constructor(dc, rst, spi) {
		this.spi = spi;
		this.dc = dc;
		this.rst = rst;
		this.default_font = 'SMALL';
		this.logo = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xFC, 0xFE, 0xFF, 0xFC, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF0, 0xF0, 0xE0, 0xE0, 0xC0, 0x80, 0xC0, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x1F, 0x3F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0xC7, 0xC7, 0x87, 0x8F, 0x9F, 0x9F, 0xFF, 0xFF, 0xFF, 0xC1, 0xC0, 0xE0, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0xFC, 0xFC, 0xFC, 0xFE, 0xFE, 0xFE, 0xFC, 0xFC, 0xF8, 0xF8, 0xF0, 0xE0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0xF1, 0xFB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x1F, 0x0F, 0x0F, 0x87, 0xE7, 0xFF, 0xFF, 0xFF, 0x1F, 0x1F, 0x3F, 0xF9, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x0F, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x7E, 0x3F, 0x3F, 0x0F, 0x1F, 0xFF, 0xFF, 0xFF, 0xFC, 0xF0, 0xE0, 0xF1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0xF0, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x0F, 0x1F, 0x3F, 0x7F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x7F, 0x1F, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 ];
		this.buffer = Buffer.alloc((LCDWIDTH*(LCDHEIGHT/8)));
		
		debug("Class constructed");
	}
	command(c) {
		debug(`Executing command ${c}`);
		return new Promise( ( resolve, reject ) => {
			gpio.write(this.dc, false, err => {
				if (err) return reject(err);

				this.spi.transfer(Buffer.from([ c ]),function(err, buf) {
					var s = "";
					for (var i=0; i < buf.length; i++) {
						s = s + buf[i] + " ";
						//console.log(s);
					}
					resolve(buf);
				});
			});
		});
	}
	extended_command(c) {
		debug(`Executing extended command ${c}`);
		return this.command( 0x20 | 0x01 )
		.then( ()=> this.command(c) )
		.then( ()=> this.command(0x20) )
		.then( ()=> this.command(0x08 | 0x4) )
	}
	data(c) {
		debug("Writing data");
		return new Promise( ( resolve, reject ) => {
			gpio.write(this.dc, true, err => {
				return reject(err);
				this.spi.transfer(Buffer.from([ c ]),function(err, buf) {
					var s = "";
					for (var i=0; i < buf.length; i++) {
						s = s + buf[i] + " ";
						//console.log(s);
					}
					resolve(buf);
				});
			});
		});
	}
	begin(contrast = 55, bias = 4) {
		//gpio.setMode(gpio.MODE_BCM);
		debug("Starting class");
		return Promise.all([
			new Promise( (resolve, reject) => {
				debug(`D/C: Pin ${this.dc}`);
				gpio.setup(this.dc, gpio.DIR_OUT, err => {
					if (err) {
						debug(`D/C pin (${this.dc}) is not ready`);
						return reject(err);
					}
					debug(`D/C pin (${this.dc}) is ready`);
					resolve(this.dc);
				});
			}),
			new Promise( (resolve, reject) => {
				debug(`RESET Pin ${this.rst}`);
				gpio.setup(this.rst, gpio.DIR_OUT, err => {
					if (err) {
						debug(`Reset pin (${this.rst}) is not ready`);
						return reject(err);
					}
					debug(`Reset pin (${this.rst}) is ready`);
					resolve(this.rst);
				});
			}),
		])
		.then( pins => {
			debug(`Set pins ${pins}`);
		})
		.then( () => this.reset() )
		.then( () => this.set_bias(bias) )
		.then( () => this.set_contrast(contrast) )
	}
	reset() {
		// Resets the display
		debug("Resetting the display");
		return new Promise( (resolve, reject) => {
			debug(`Resetting display on pin ${this.rst}`);
			gpio.write(this.rst, false, err => {
				if (err) return reject(err);
				setTimeout( () => {
					gpio.write(this.rst, true, err => {
						if (err) return reject(err);
						resolve();
					});
				}, 100);
			});
		});
	}
	text(text, line=1, options={}){
		var {
			underline = false,
			strikethrough = false,
			offset = 0,
			font = this.default_font
		} = options;
		
		line = Math.min(Math.max(1, line), 6)-1;
		
		var cursor = 0;
		var startOfLine = LCDWIDTH*line;
		var index = startOfLine+offset;
		var endOfLine = startOfLine+LCDWIDTH;


		while (true){
			var char = fonts[font][text[cursor]];

			if(char){
				for(var j in char){
					var col = char[j];
					
					if(underline) col = col | 0x80;
					if(strikethrough) col = col | 0x08;

					this.buffer[index] = col;
					index++;
	
					if(index==endOfLine) return;
				}
			}else{
				this.buffer[index] = 0x00;
				index++;

				if(index==endOfLine) return;
			}
			cursor++;
		}
	}

	display() {
		debug("Pushing display buffer to display");
		return this.command(0x40)
		.then( () => this.command(0x80) )
		.then( () => {
			return new Promise( (resolve, reject) => {
				gpio.write(this.dc, true, err => {
					if (err) return reject(err);
					try {
						this.spi.transfer(this.buffer,function(err, buf) {
							var s = "";
							for (var i=0; i < buf.length; i++) {
								s = s + buf[i] + " ";
								//console.log(s);
							}
						});
					} catch (e) {
						reject(e);
					}
				});
			});
		});
	}
	// draw(){
	// 	var data = [];
	// 	this.image.data.forEach((el, i) => {
	// 		if(i%4 == 0){
	// 			data.push(el);
	// 		}
	// 	});

	// 	var index = 0;
	// 	const bits = 8;
	// 	const rows = LCDHEIGHT/bits;

	// 	for(var y=0; y<rows; y++ ){
	// 		for(var x=0; x<LCDWIDTH; x++){
	// 			var bin = [0,0,0,0,0,0,0,0];

	// 			for(var i=0; i<bits; i++){
	// 				var channelIndex = x+(y*LCDWIDTH*bits /* Start Position */)+(i*LCDWIDTH /* Offset Position */);
	// 				var value = data[channelIndex];
	// 				bin[i] = value < (255/2) ? 1 : 0; // 0 is White (off) 1 is Black(on)
	// 			}
				
	// 			this.buffer[index] = parseInt(bin.reverse().join(''), 2);
	// 			index++;
	// 		}
	// 	}
		

	// 	this.display();
	// }
	clear() {
		debug("Clearing display buffer");
		this.buffer = Buffer.from( new Array((LCDWIDTH * LCDHEIGHT / 8)).fill(0x00) );
	}
	set_contrast(contrast) {
		contrast = Math.max(0, Math.min(contrast, 127));
		debug(`Setting contrast to ${contrast} (Clamped 0-127)`);
		return this.extended_command( 0x80 | contrast );
	}
	set_bias(bias) {
		debug(`Setting bias to ${bias}`);
		return this.extended_command( 0x10 | bias );
	}
}

const spi = SPI.initialize("/dev/spidev0.0");
let screen = new NokiaScreen(16, 18, spi);
var ip = require("ip");

screen.begin(55, 4).then( () => {
	// screen.text('ABCD"EFG"');
	screen.text('MISSION DRONE',1, {
		underline: true
	});
	screen.text(`IP: ${ip.address()}`, 2);
	screen.display();

	var warn = false;
	setInterval(() => {
		warn = !warn;

		if(warn){
			screen.text('!! WATER',6, {
				// offset: 48
			});
		}else{
			screen.text('',6, {
				// offset: 40
			});
		}
		screen.display();
	}, 1000);
})
.catch( err => {
	console.log(`Error on begin: `, err);
});


module.exports = NokiaScreen;